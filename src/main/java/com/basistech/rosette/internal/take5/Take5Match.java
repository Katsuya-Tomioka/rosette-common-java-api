/******************************************************************************
 ** This data and information is proprietary to, and a valuable trade secret
 ** of, Basis Technology Corp.  It is given in confidence by Basis Technology
 ** and may only be used as permitted under the license agreement under which
 ** it has been distributed, and in no other way.
 **
 ** Copyright (c) 2000-2008 Basis Technology Corporation All rights reserved.
 **
 ** The technical data and information provided herein are provided with
 ** `limited rights', and the computer software provided herein is provided
 ** with `restricted rights' as those terms are defined in DAR and ASPR
 ** 7-104.9(a).
 ******************************************************************************/
//CHECKSTYLE:OFF
package com.basistech.rosette.internal.take5;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * A single match generated by a dictionary lookup.  This object can be
 * queried for the value data associated with the match.
 * <P>
 * Sometimes a Take5Match is used to represent an intermediate state of the
 * underlying state machine which is <EM>not</EM> an actual match.  But
 * this is not the usual case.  The only way to get such a "match" is by
 * calling {@link Take5Dictionary#getStartMatch Take5Dictionary.getStartMatch}, {@link
 * Take5Dictionary#nextLetters(Take5Match) Take5Dictionary.nextLetters} or {@link
 * Take5Dictionary#walk Take5Dictionary.walk}.
 */
public class Take5Match {
    Take5Dictionary dict; /* Reference back to the dictionary we can from. */
    // XXX in the original C Take5, the "length" was the only publicly
    // advertised member in a match.  But here, it is the only member that
    // <EM>isn't</EM> public!
    int length; /* Length of the matched prefix. */

    /**
     * Deprecated as public; use {@link #getIndex()}.  This should never
     * have been made public. It should be package-local.
     * <P>
     * Unfortunately, if you are calling {@link
     * Take5Dictionary#nextLetters(int, int)} or {@link
     * Take5Dictionary#take5Search(char[], int, int, Take5Match,
     * Take5Match[], int, int)}, you currently must use this to access the
     * 32-bit internal index.
     */
    public int index; /* Index associated with the matched prefix. */

    /**
     * Deprecated as public.  This should never have been made public.  It
     * should be package-local.
     * <P>
     * Unfortunately, if you are calling {@link
     * Take5Dictionary#nextLetters(int, int)} or {@link
     * Take5Dictionary#take5Search(char[], int, int, Take5Match,
     * Take5Match[], int, int)}, you currently must use this to access the
     * 32-bit internal state.
     */
    public int state;

    /**
     * This is set by {@link Take5Dictionary#nextLetters(Take5Match)} to the next
     * character.
     */
    public char c;

    /**
     * Initializes a new match object. The object should not be used until
     * it internal values have been filled in.
     */
    public Take5Match() {
        this.dict = null;       // XXX why bother?
        this.length = 0;        // XXX why bother?
        this.index = 0;         // XXX why bother?
    }

    /**
     * Initializes a new match object to be a copy of an existing match.
     */
    public Take5Match(Take5Match old) {
        dict = old.dict;
        length = old.length;
        index = old.index;
        state = old.state;
        c = old.c;
    }

    // The constructor we use internally most of the time:
    Take5Match(Take5Dictionary dict, int length, int index, int state) {
        this.dict = dict;
        this.length = length;
        this.index = index;
        this.state = state;
    }

    // XXX This has one, possibly spurious, caller.
    void reset() {
        dict = null;
        length = 0;
        index = 0;
    }

    /**
     * Get the length of the matching prefix string.
     */
    public int getLength() {
        return length;
    }

    /**
     * Get the index of the matched word.
     * <P>
     * If you are using this because you are calling {@link
     * Take5Dictionary#nextLetters(int, int)} or {@link
     * Take5Dictionary#take5Search(char[], int, int, Take5Match,
     * Take5Match[], int, int)}, you <EM>must</EM> reference the {@link
     * #index} slot directly.
     *
     * @return the index.
     */
    public int getIndex() {
        return index - dict.indexOffset;
    }

    /**
     * Return the state of the matched word.
     * <P>
     * If you are using this because you are calling {@link
     * Take5Dictionary#nextLetters(int, int)} or {@link
     * Take5Dictionary#take5Search(char[], int, int, Take5Match,
     * Take5Match[], int, int)}, you should just reference the {@link
     * #state} slot directly.
     *
     * @return the 32-bit internal state.
     * @deprecated This should never have existed.
     */
    @Deprecated
    public int getState() {
        return state;
    }

    /**
     * Test whether this match represents an actual accept state.
     * <P>
     * Normally the caller knows whether a match is a true match, but
     * {@link Take5Dictionary#getStartMatch()} and {@link
     * Take5Dictionary#nextLetters(Take5Match)} can return matches that
     * might or might not represent an actual match.  In just those cases,
     * this predicate can be used to check.  In all other cases, the
     * results are not guaranteed to be meaningful.
     *
     * @return true if this is an accept state.
     */
    public boolean isAcceptState() {
        return (state & 1) != 0;
    }

    /**
     * Retrieve a ByteBuffer containing a Take5 value of a known size.
     * <P>
     * If you <EM>don't</EM> know the size, you should be calling {@link
     * #getOffsetValue()}.
     *
     * @param dataLength
     * @return a ByteBuffer
     */
    // Although most callers of this probably actually want getOffsetValue,
    // there is no reason to deprecate this:
    // @deprecated 1.3.7: use {@link #getOffsetValue()}.
    // @Deprecated
    public ByteBuffer getComplexData(int dataLength) throws Take5Exception {
        int ptr = getOffsetValue();
        dict.data.position(ptr);
        dict.data.limit(ptr + dataLength);
        ByteBuffer rbb = dict.data.slice();
        rbb.order(ByteOrder.nativeOrder());
        dict.data.position(0);
        dict.data.limit(dict.data.capacity());
        return rbb;
    }

    /**
     * Get the single-precision float value associated with the matched prefix.
     */
    public float getFloatValue() throws Take5Exception {
        if (dict.valueSize != 4) {
            throw new Take5Exception(Take5Exception.VALUE_SIZE_MISMATCH);
        }
        int ptr = getOffsetValue();
        return dict.data.getFloat(ptr);
    }

    /**
     * Get the integer value associated with the matched prefix.
     */
    public int getIntValue() throws Take5Exception {
        int ptr;
        switch (dict.valueFormat & 0xFF000000) {
        default:
            throw new Take5Exception(Take5Exception.UNSUPPORTED_VALUE_FORMAT);
        case Take5Dictionary.VALUE_FORMAT_NONE:
            throw new Take5Exception(Take5Exception.NO_NUMBERS_HERE);
        case Take5Dictionary.VALUE_FORMAT_INDEX:
            return index - dict.indexOffset;
        case Take5Dictionary.VALUE_FORMAT_FIXED:
            ptr = dict.valueData + index * dict.valueSize;
            break;
        case Take5Dictionary.VALUE_FORMAT_INDIRECT:
            ptr = dict.data.getInt(dict.valueData + index * 4);
            break;
        }
        switch (dict.valueSize) {
        default:
            throw new Take5Exception(Take5Exception.VALUE_SIZE_MISMATCH);
        case 1:
            return dict.data.get(ptr);
        case 2:
            return dict.data.getShort(ptr);
        case 4:
            return dict.data.getInt(ptr);
        }
    }

    /**
     * Get the double-precision float value associated with the matched prefix.
     */
    public double getDoubleValue() throws Take5Exception {
        if (dict.valueSize != 8) {
            throw new Take5Exception(Take5Exception.VALUE_SIZE_MISMATCH);
        }
        int ptr = getOffsetValue();
        return dict.data.getDouble(ptr);
    }

    /**
     * Convenience accessor for Strings.  For all other payloads, where the
     * size is unknown in advance, the caller should use {@link
     * #getOffsetValue}.  Get the String value associated with the matched
     * prefix.  Warning, this assumes that the value is in a particular
     * format: null-terminated!  Use getOffsetValue for more complex cases.
     *
     * @return string value assuming either UTF-8 (for data size 1) or
     * UTF-16 (for data size 2).
     */
    public String getStringValue() throws Take5Exception {
        int ptr = dict.data.getInt(dict.valueData + index * 4);
        int inc = dict.valueSize;
        int len = 0;
        String rv;

        if (ptr == 0) {
            return null;
        }
        if ((dict.valueFormat & 0xFF000000) != Take5Dictionary.VALUE_FORMAT_INDIRECT) {
            throw new Take5Exception(Take5Exception.NO_POINTERS_HERE);
        }

        switch (inc) {

        default:
            throw new Take5Exception(Take5Exception.VALUE_SIZE_MISMATCH);

        case 1:
            while (dict.data.get(ptr + len) != 0) {
                len++;
            }
            byte[] bytes = new byte[len];
            for (int i = 0; i < len; i++) {
                bytes[i] = dict.data.get(ptr + i);
            }
            try {
                rv = new String(bytes, "UTF-8");
            } catch (java.io.UnsupportedEncodingException e) {
                throw new Take5Exception(Take5Exception.BAD_DATA);
            }
            break;

        case 2:
            while (dict.data.getShort(ptr + 2 * len) != 0) {
                len++;
            }
            char[] chars = new char[len];
            for (int i = 0; i < len; i++) {
                chars[i] = dict.data.getChar(ptr + 2 * i);
            }
            rv = new String(chars);
            break;
        }

        return rv;
    }

    /**
     * Get the offset into the data file at which the result can be found.
     * The caller must use their own access to the underlying ByteBuffer to
     * retrieve the actual values.
     * @return the offset of the payload data in the take5;
     */
    public int getOffsetValue() throws Take5Exception {
        switch (dict.valueFormat & 0xFF000000) {
        default:
            throw new Take5Exception(Take5Exception.UNSUPPORTED_VALUE_FORMAT);
        case Take5Dictionary.VALUE_FORMAT_NONE:
        case Take5Dictionary.VALUE_FORMAT_INDEX:
            throw new Take5Exception(Take5Exception.NO_POINTERS_HERE);
        case Take5Dictionary.VALUE_FORMAT_FIXED:
            return dict.valueData + index * dict.valueSize;
        case Take5Dictionary.VALUE_FORMAT_INDIRECT:
            return dict.data.getInt(dict.valueData + index * 4);
        }
    }

    /**
     * String representation of a match.
     */
    public String toString() {
        return "[Match:" +
            " index = " + index +
            " state = " + state +
            " length = " + length +
            "]";
    }
}
