/******************************************************************************
 ** This data and information is proprietary to, and a valuable trade secret
 ** of, Basis Technology Corp.  It is given in confidence by Basis Technology
 ** and may only be used as permitted under the license agreement under which
 ** it has been distributed, and in no other way.
 **
 ** Copyright (c) 2000-2008 Basis Technology Corporation All rights reserved.
 **
 ** The technical data and information provided herein are provided with
 ** `limited rights', and the computer software provided herein is provided
 ** with `restricted rights' as those terms are defined in DAR and ASPR
 ** 7-104.9(a).
 ******************************************************************************/

//CHECKSTYLE:OFF
// This code is a bit too quirky to clean up.
package com.basistech.rosette.internal.take5;

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.CharBuffer;
import java.util.ArrayList;
import java.util.List;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.TimeZone;

/**
 * This class implements loading and usage of a Take5 binary dictionary.
 */
// CHECKSTYLE:OFF
public class Take5Dictionary {
    /* Binary format version numbers. */
    private static final int VERSION_5_0 = 0x00000500;
    private static final int VERSION_5_1 = 0x00000501;
    private static final int VERSION_5_2 = 0x00000502;
    private static final int VERSION_5_3 = 0x00000503;
    private static final int VERSION_5_4 = 0x00000504;
    private static final int VERSION_5_5 = 0x00000505;
    private static final int VERSION_5_6 = 0x00000506;
    private static final int VERSION_MINIMUM = VERSION_5_0;

    /* Versions supported by runtime. */
    // XXX Why are these public?
    /**
     * Deprecated as public.
     */
    public static final int RT_MIN_VERSION = VERSION_5_0;
    /**
     * Deprecated as public.
     */
    public static final int RT_MAX_VERSION = VERSION_5_6;

    /* constant used to convert byte index to a char index */
    public static final int BYTES_PER_CHAR = Character.SIZE/Byte.SIZE;

    ByteBuffer data; /* Binary dictionary data. */
    char[] charData; /* Binary dictionary data in the heap.  */
    long dataSize; /* Size of dictionary data. */
    byte[] skipBits; /* Characters to skip. */
    boolean squeezeSpaces;      /* Should we squeeze spaces? */

    int valueData; /* Beginning of value data section. */
    int valueFormat; /* Value data format. */
    int valueSize; /* Value data size. */

    int keyCheckData; /* Beginning of key check data section. */
    int keyCheckFormat; /* Key check data format. */

    int fsaData; /* Beginning of entry point vector. */
    int fsaEngine; /* FSA engine type. */

    int minVersion; /* Minimum engine supported. */
    int fileVersion; /* Maximum engine supported. */
    int flags; /* Engine flags. */
    String copyrightString; /* Copyright string. */
    int buildDay; /* Day dictionary was built. */
    int buildMsec; /* Time dictionary was built. */

    private Map<String, String> metadata;

    int entryPointCount;
    int entryPointHeaderSize;
    List<String> entryPointNames; // The names of all the entry points, in
                                  // the order that they occur in the
                                  // binary.

    // Per entry point:
    int currentEntryPoint;      // The index of the current entry point
    int stateStart;             // State to start in.
    int indexStart;             // Index value to start with.
    int indexOffset;            // The smallest index generated by this entry point.
    int contentFlags;           // Content flags.
    int contentMinVersion;      // Minimum content version.
    int contentMaxVersion;      // Maximum content version.
    int wordCount;              // Words recognized.
    int stateCount;             // Number of FSA states.
    int acceptStateCount;       // Number of accept states.
    int edgeCount;              // Number of graph edges.
    int acceptEdgeCount;        // Number of accepting edges.
    int guardIndexDelta;        // For inverse lookups.
    int maxMatches;             // Maximum number of matches to expect.
    int maxWordLength;          // Length of longest word.
    int minCharacter;           // Minimum character value.
    int maxCharacter;           // Maximum character value.
    int maxValueSize;           // Maximum value size, if storing values.
    int indexCount;             // Possible index values.
    int tableCount;             // Number of hash function table entries.

    /**
     * Initialize a Take5Dictionary object to match against the dictionary
     * stored in the given ByteBuffer at the "main" entry point.
     *
     * @param fileData ByteBuffer containing a Take5 binary
     * @param fileSize length of the Take5 binary
     * @throws Take5Exception if there is a problem with the given input.
     */
    public Take5Dictionary(ByteBuffer fileData, long fileSize) throws Take5Exception {
        this(fileData, fileSize, "main");
    }

    /**
     * Initialize a Take5Dictionary object to match against the dictionary
     * stored in the given ByteBuffer with the named entry point.
     *
     * @param fileData ByteBuffer containing a Take5 binary
     * @param fileSize length of the Take5 binary
     * @param entryPoint name of the initial entry point to select
     * @throws Take5Exception if there is a problem with the given input.
     */
    public Take5Dictionary(ByteBuffer fileData, long fileSize, String entryPoint) throws Take5Exception {
        data = fileData.asReadOnlyBuffer();
        dataSize = fileSize;
        skipBits = null;
        squeezeSpaces = false;
        metadata = new HashMap<String, String>();
        readHeader();

        // Initialize per-file engine data.
        switch (fsaEngine) {

        case ENGINE_SEARCH:
            // Do not insist that (keyCheckFormat == KEYCHECK_FORMAT_NONE) here.  By keeping
            // our options open for what that might mean, we allow for potential backwards
            // compatibility.

            // AAARRRGGGHHH!!!  This is horrible!  It is a complete accident that both Take5
            // compilers happen to put the value data segment <EM>after</EM> the state machine.
            // I could easily have changed that and this code would start reading in to little
            // data or too much data!  X!X!X
            int charDataSize = (valueData <= 0 ? (int) dataSize : valueData);
            charData = new char[(charDataSize+1)/BYTES_PER_CHAR];
            data.rewind();
            data.asCharBuffer().get(charData);
            break;

        case ENGINE_PERFHASH:
            break;

        default:
            throw new Take5Exception(Take5Exception.UNSUPPORTED_ENGINE);
        }

        readEntryPoint(entryPoint);
    }

    /**
     * Get copyright notices attached to the dictionary.
     */
    public String getCopyright() {
        return copyrightString;
    }

    /**
     * Get content flags set on the dictionary.
     */
    public int getContentFlags() {
        return contentFlags;
    }

    /**
     * Get the minimum version supported by the content of this dictionary.
     */
    public int getMinimumContentVersion() {
        return contentMinVersion;
    }

    /**
     * Get the maximum version supported by the content of this dictionary.
     */
    public int getMaximumContentVersion() {
        return contentMaxVersion;
    }

    /**
     * The maximum number of matches a request for multiple matches can return. If this is not known a value
     * of -1 is returned.
     */
    public int maximumMatchCount() {
        return maxMatches;
    }

    /**
     * The maximum length of a word in the dictionary. If the language is infinite this is -1.
     */
    public int maximumWordLength() {
        return maxWordLength;
    }

    /**
     * The highest value character stored in the dictionary.
     */
    public char maximumCharacter() {
        return (char)maxCharacter;
    }

    /**
     * The lowest value character stored in the dictionary.
     */
    public char minimumCharacter() {
        return (char)minCharacter;
    }

    /**
     * Maximum size of a value, zero if there are no values stored.
     */
    public int maximumValueSize() {
        return maxValueSize;
    }

    /**
     * Number of words in the dictionary, -1 if the language is infinite or this value is unknown.
     */
    public int wordCount() {
        return wordCount;
    }

    /**
     * Number of possible index values, -1 if the language is infinite or this value is unknown.
     */
    public int indexCount() {
        return indexCount;
    }

    /**
     * Number of states in the dictionary's FSA.
     */
    public int fsaStateCount() {
        return stateCount;
    }

    /**
     * Number of accept states in the dictionary's FSA.
     */
    public int fsaAcceptStateCount() {
        return acceptStateCount;
    }

    /**
     * Number of edges in the dictionary's FSA.
     */
    public int fsaEdgeCount() {
        return edgeCount;
    }

    /**
     * Number of accept edges in the dictionary's FSA.
     */
    public int fsaAcceptEdgeCount() {
        return acceptEdgeCount;
    }

    /**
     * For complex payload, the accessors in the Take5Match cannot do all the decomposition. The caller has to
     * get an offset and fend for itself.
     *
     * @return the entire take5.
     */
    public ByteBuffer getData() {
        ByteBuffer buffer = data.asReadOnlyBuffer();
        buffer.position(0);
        buffer.limit(buffer.capacity());
        buffer.order(ByteOrder.nativeOrder());
        return buffer;
    }

    /**
     * Date and time this dictionary was generated.
     */
    public Date creationDate() {
        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        // buildDay = (YYYY * 12 + MM) * 31 + DD;
        int tmp = buildDay;
        int day = 1 + tmp % 31; tmp /= 31;
        int month = tmp % 12; tmp /= 12;
        int year = tmp;
        // buildMsec = the number of milliseconds since midnight on buildDay
        tmp = buildMsec;
        if (tmp >= 86400000) {
            // Don't trust Java libraries to handle leap seconds!
            tmp = 86399999;
        }
        int msec = tmp % 1000; tmp /= 1000;
        int second = tmp % 60; tmp /= 60;
        int minute = tmp % 60; tmp /= 60;
        cal.set(year, month, day, tmp, minute, second);
        cal.set(Calendar.MILLISECOND, msec);
        return cal.getTime();
    }

    /**
     * Return any metadata supplied at build-time.
     */
    public Map<String, String> getMetadata() {
        return metadata;
    }

    /**
     * Set a list of characters to skip over when preforming a match.  This
     * takes the form of an array of exactly 8192 elements such that a
     * character is skipped if skipBits[c >> 3] & (1 << (c & 7)) is
     * non-zero.  Character skipping can be completely disabled by passing
     * null.
     *
     * @param skipBits the new skipBits array
     * @return the previous skipBits array
     */
    public byte[] setSkipBits(byte[] skipBits) {
        if (skipBits != null && skipBits.length != 8192) {
            throw new IllegalArgumentException("skipBits must have exactly 8192 elements.");
        }

        byte[] previous = this.skipBits;
        this.skipBits = skipBits;
        return previous;
    }

    /**
     * Turn space squeezing on or off.  When space squeezing is enabled,
     * all but the first space in a run of consecutive spaces will be
     * skipped over when performing a match.  (Only the character 0x0020
     * counts as a space!)  Space squeezing is disabled by default.
     *
     * @param squeezeSpaces Should we squeeze spaces?
     * @return the previous setting
     */
    public boolean setSqueezeSpaces(boolean squeezeSpaces) {
        boolean previous = this.squeezeSpaces;
        this.squeezeSpaces = squeezeSpaces;
        return previous;
    }

    /**
     * Selects a different entry point.  Calling this will invalidate all
     * the outstanding Take5Match objects, so you better know what you are
     * doing!
     *
     * @param name the name of the entry point to select
     */
    public void setEntryPoint(String name) throws Take5Exception {
        readEntryPoint(name);
    }

    /**
     * Searches for a match in the dictionary of exactly the string
     * provided. If such a match is found the associated Take5Match object
     * is returned, otherwise null.
     *
     * @param data the key
     * @return the match object
     */
    public Take5Match matchExact(String data) {
        Take5Match match = new Take5Match();
        int c = matchExactInternal(data.toCharArray(), 0, data.length(), match);
        if (c == 0) {
            return null;
        }
        if (match.length == data.length()) {
            return match;
        }
        return null;
    }

    /**
     * Searches for a match in the dictionary of exactly the string
     * provided. If such a match is found the associated Take5Match object
     * is returned, otherwise null.
     *
     * @param data buffer containing the key
     * @param offset offset of the key in the buffer
     * @param length length of the key
     * @return the match object
     */
    public Take5Match matchExact(char[] data, int offset, int length) {
        Take5Match match = new Take5Match();
        int c = matchExactInternal(data, offset, length, match);
        if (c == 0) {
            return null;
        }
        if (match.length == length) {
            return match;
        }
        return null;
    }

    /**
     * Searches for a match in the dictionary of exactly the string
     * provided. If such a match is found, the return value is true and the
     * result object is filled in. Otherwise, the return value is false and
     * the result object contents are undefined.
     *
     * @param data buffer containing the key
     * @param offset offset of the key
     * @param length length of the key
     * @param result object to fill with the match results
     * @return true for success
     */
    public boolean matchExact(char[] data, int offset, int length, Take5Match result) {
        result.reset();         // XXX this is the <EM>only</EM> use of reset!!
        int c = matchExactInternal(data, offset, length, result);
        if (c == 0) {
            return false;
        }
        if (result.length == length) {
            return true;
        }
        return false;
    }

    // For exact matches only.  If the key was not found, this should return 0.  If the key was
    // found, this should fill in the Take5Match and return 1.
    private int matchExactInternal(char[] data, int offset, int length, Take5Match result) {
        switch (fsaEngine) {

        case ENGINE_SEARCH:
            return take5SearchInternal(data, offset, length, result, null, stateStart, indexStart);

        case ENGINE_PERFHASH:
            return perfectHashLookup(data, offset, length, result);

        default:
            throw new Take5RuntimeException(Take5Exception.UNSUPPORTED_ENGINE,
                                            "(This error should be impossible here!)");
        }
    }

    /**
     * Searches for the longest string matching the given data. The
     * Take5Match object associated with that string is returned, otherwise
     * null.
     *
     * @param data the key
     * @return the match object
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     */
    public Take5Match matchLongest(String data) {
        Take5Match match = new Take5Match();
        int c = take5SearchInternal(data.toCharArray(), 0, data.length(), match, null,
                                    stateStart, indexStart);
        if (c == 0) {
            return null;
        }
        return match;
    }
    /**
     * Searches for the longest string matching the given key, specified by
     * a buffer, offset, and length.  The Take5Match object associated with
     * that string is returned, otherwise null.
     *
     * @param data buffer containing the key.
     * @param offset offset of the key in the buffer.
     * @param length length of the key.
     * @return the match object.
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     */
    public Take5Match matchLongest(char[] data, int offset, int length) {
        Take5Match match = new Take5Match();
        int c = take5SearchInternal(data, offset, length, match, null,
                                    stateStart, indexStart);
        if (c == 0) {
            return null;
        }
        return match;
    }

    /**
     * Finds all possible matches for prefixes of the given string. Up to
     * the length of matches results are generated.
     *
     * @param data the key
     * @param matches an array to store the resulting matches in
     * @return the number of valid results
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     */
    public int matchMultiple(String data, Take5Match[] matches) {
        int c = take5SearchInternal(data.toCharArray(), 0, data.length(), null, matches,
                                    stateStart, indexStart);
        return c > matches.length ? matches.length : c;
    }

    /**
     * Finds all possible matches for prefixes of the given key, specified
     * by a buffer, offset, and length.  The caller controls the number of
     * matches returned via the size of the 'matches' array.
     *
     * @param data buffer containing the key
     * @param offset offset of the key in the buffer
     * @param length length of the key
     * @param matches an array to store the resulting matches in
     * @return the number of valid results
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     */
    public int matchMultiple(char[] data, int offset, int length, Take5Match[] matches) {
        int c = take5SearchInternal(data, offset, length, null, matches,
                                    stateStart, indexStart);
        return c > matches.length ? matches.length : c;
    }

    // This just needs to be large enough to cover the first 9 fields in
    // the header, because the 9th field is the total_size field:
    private static final int HEADER_SIZE = 9 * 4;

    private static final int FLAG_LITTLE_ENDIAN = 0x01;
    @SuppressWarnings("unused")
    private static final int FLAG_OBFUSCATION = 0x02;
    @SuppressWarnings("unused")
    private static final int FLAG_LOOKUP_AUTOMATON = 0x04;

    @SuppressWarnings("unused")
    private static final int ENGINE_TAKE3 = 0x00000001;
    private static final int ENGINE_SEARCH = 0x00000002;
    private static final int ENGINE_PERFHASH = 0x00000003;

    private static final int KEYCHECK_FORMAT_NONE = 0x00000000;
    private static final int KEYCHECK_FORMAT_HASH32 = 0x00000001;
    private static final int KEYCHECK_FORMAT_STR = 0x00000002;

    static final int VALUE_FORMAT_NONE = 0x01000000;
    static final int VALUE_FORMAT_INDEX = 0x02000000;
    static final int VALUE_FORMAT_FIXED = 0x03000000;
    static final int VALUE_FORMAT_INDIRECT = 0x04000000;

    /**
     * Reads the header of the given data file.
     */
    private void readHeader() throws Take5Exception {
        if (dataSize < HEADER_SIZE) {
            throw new Take5Exception(Take5Exception.FILE_TOO_SHORT);
        }

        data.order(ByteOrder.nativeOrder());

        // Check magic.
        if (!(data.get() == 'T' && data.get() == '4' && data.get() == 'K' && data.get() == '3')) {
            throw new Take5Exception(Take5Exception.BAD_DATA);
        }

        fileVersion = data.getInt();
        contentMaxVersion = data.getInt();
        flags = data.getInt();
        contentFlags = data.getInt();
        minVersion = data.getInt();
        contentMinVersion = data.getInt();
        data.getInt(); /* required_alignment */
        int total_size = data.getInt();

        // Check file size.
        // (Do it <EM>now</EM> before reading data that might not exist!)
        if (total_size > dataSize) {
            throw new Take5Exception(Take5Exception.FILE_TOO_SHORT);
        }
        dataSize = total_size;

        int copyright_string = data.getInt();
        int copyright_size = data.getInt();
        valueData = data.getInt();
        valueFormat = data.getInt();
        fsaData = data.getInt();
        fsaEngine = data.getInt();
        wordCount = data.getInt();
        stateCount = data.getInt();
        acceptStateCount = data.getInt();
        edgeCount = data.getInt();
        acceptEdgeCount = data.getInt();

        // Reverse bytes from network order fields.
        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
            fileVersion = reverseBytes(fileVersion);
            flags = reverseBytes(flags);
            minVersion = reverseBytes(minVersion);
        }

        // Check byte order.
        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN != ((flags & FLAG_LITTLE_ENDIAN) != 0)) {
            throw new Take5Exception(Take5Exception.WRONG_BYTE_ORDER);
        }

        // Check version numbers.
        if (fileVersion < VERSION_MINIMUM) {
            throw new Take5Exception(Take5Exception.FILE_TOO_OLD);
        }
        if (fileVersion < minVersion) {
            throw new Take5Exception(Take5Exception.BAD_DATA);
        }
        if (fileVersion > RT_MAX_VERSION) {
            fileVersion = RT_MAX_VERSION;
        }
        if (minVersion < RT_MIN_VERSION) {
            minVersion = RT_MIN_VERSION;
        }
        if (fileVersion < RT_MIN_VERSION) {
            throw new Take5Exception(Take5Exception.FILE_TOO_OLD);
        }
        if (minVersion > RT_MAX_VERSION) {
            throw new Take5Exception(Take5Exception.FILE_TOO_NEW);
        }

        // Extract copyright string.
        if (copyright_string != 0) {
            byte[] string = new byte[copyright_size];
            for (int i = 0; i < copyright_size; i++) {
                string[i] = data.get(copyright_string + i);
            }
            copyrightString = new String(string); // XXX always ASCII?
        }

        // Version 5.1 specific fields.
        if (fileVersion >= VERSION_5_1) {
            maxMatches = data.getInt();
        } else {
            maxMatches = 0;
        }

        // Version 5.2 specific fields.
        if (fileVersion >= VERSION_5_2) {
            maxWordLength = data.getInt();
            maxValueSize = data.getInt();
            minCharacter = data.getInt();
            maxCharacter = data.getInt();
            buildDay = data.getInt();
            buildMsec = data.getInt();
        } else {
            maxWordLength = 0;
            maxValueSize = -1;
            minCharacter = 0x0000;
            maxCharacter = 0xFFFF;
            buildDay = 0;
            buildMsec = 0;
        }

        if (fileVersion >= VERSION_5_3) {
            int metadata_string = data.getInt();
            int metadata_size = data.getInt();
            if (metadata_size > 0) {
                // byte order?
                ByteBuffer metadataSubset = data.duplicate();
                metadataSubset.position(metadata_string);
                metadataSubset.limit(metadata_string + 2 * metadata_size);
                metadataSubset.order(ByteOrder.nativeOrder());
                CharBuffer charified = metadataSubset.asCharBuffer();
                // this has embedded nulls, now we get to parse them out.
                while (charified.hasRemaining()) {
                    StringBuilder builder = new StringBuilder();
                    char c;
                    while (0 != (c = charified.get())) {
                        builder.append(c);
                    }
                    String key = builder.toString();
                    builder = new StringBuilder();
                    while (0 != (c = charified.get())) {
                        builder.append(c);
                    }
                    String value = builder.toString();
                    metadata.put(key, value);
                }
                metadata = Collections.unmodifiableMap(metadata);
            }
        }

        if (fileVersion >= VERSION_5_4) {
            entryPointCount = data.getInt();
            entryPointHeaderSize = data.getInt();
            entryPointNames = new ArrayList<String>(entryPointCount);
            for (int i = 0; i < entryPointCount; i++) {
                // +12 because there are three 32-bit ints in the header first...
                int beg = data.getInt(fsaData + (i * entryPointHeaderSize) + 12);
                int end = beg;
                while (data.get(end) != 0) {
                    end++;
                }
                int len = end - beg;
                byte[] buf = new byte[len];
                for (int j = 0; j < len; j++) {
                    buf[j] = data.get(beg + j);
                }
                try {
                    entryPointNames.add(i, new String(buf, "ASCII"));
                } catch (UnsupportedEncodingException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            entryPointCount = 1;
            entryPointHeaderSize = 8; // Was two ints before VERSION_5_4
            entryPointNames = new ArrayList<String>(1);
            entryPointNames.add(0, "main");
        }

        if (fileVersion >= VERSION_5_5) {
            guardIndexDelta = -1;
        } else {
            guardIndexDelta = 0;
        }

        if (fileVersion >= VERSION_5_6) {
            indexCount = data.getInt();
            keyCheckData = data.getInt();
            keyCheckFormat =  data.getInt();
        } else {
            indexCount = wordCount;
            keyCheckData = 0;
            keyCheckFormat = KEYCHECK_FORMAT_NONE;
        }

        // Initialize value reading.
        switch (valueFormat & 0xFF000000) {
        default:
            throw new Take5Exception(Take5Exception.UNSUPPORTED_VALUE_FORMAT);
        case VALUE_FORMAT_NONE:
            valueSize = 0;
            break;
        case VALUE_FORMAT_INDEX:
            valueSize = 4;
            break;
        case VALUE_FORMAT_FIXED:
        case VALUE_FORMAT_INDIRECT:
            valueSize = valueFormat & 0x00FFFFFF;
            break;
        }
    }

    /**
     * To use {@link #take5Search(char[], int, int, Take5Match,
     * Take5Match[], Take5Match)} or {@link #nextLetters(Take5Match)}, use
     * this to obtain starting values.
     *
     * @return a new match object.
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     * @see Take5Match#isAcceptState
     */
    public Take5Match getStartMatch() {
        if (fsaEngine != ENGINE_SEARCH) {
            throw new UnsupportedOperationException("This Take5Dictionary is not a state machine.");
        }
        // XXX Should we worry that someone might call setEntryPoint?
        return new Take5Match(this, 0, indexStart, stateStart);
    }

    /**
     * Read entry point header.
     */
    private void readEntryPoint(String name) throws Take5Exception {
        int i = entryPointNames.indexOf(name);
        if (i < 0) {
            throw new Take5Exception(Take5Exception.ENTRY_POINT_NOT_FOUND);
        }
        currentEntryPoint = i;
        data.position(fsaData + (i * entryPointHeaderSize));
        stateStart = data.getInt();
        indexStart = data.getInt();
        if (fileVersion >= VERSION_5_4) {
            indexOffset = data.getInt();
            data.getInt();      // skip the name -- we already have it.
            contentFlags = data.getInt();
            contentMaxVersion = data.getInt();
            contentMinVersion = data.getInt();
            wordCount = data.getInt();
            stateCount = data.getInt();
            acceptStateCount = data.getInt();
            edgeCount = data.getInt();
            acceptEdgeCount = data.getInt();
            maxMatches = data.getInt();
            maxWordLength = data.getInt();
            maxValueSize = data.getInt();
            minCharacter = data.getInt();
            maxCharacter = data.getInt();
        } else {
            indexOffset = 0;
        }
        if (fileVersion >= VERSION_5_6) {
            indexCount = data.getInt();
            tableCount = data.getInt();
        } else {
            indexCount = wordCount;
            tableCount = 0;
        }

        // Initialize per-entry-point engine data.
        switch (fsaEngine) {

        case ENGINE_SEARCH:
            break;

        case ENGINE_PERFHASH:
            break;

        default:
            throw new Take5Exception(Take5Exception.UNSUPPORTED_ENGINE);
        }
    }

    private static final int SEARCH_TYPE_BINARY = 0;
    private static final int SEARCH_TYPE_BINARY_END = 17;
    private static final int SEARCH_TYPE_LINEAR = 17;
    private static final int SEARCH_TYPE_LINEAR_END = 34;
    private static final int SEARCH_TYPE_CHOICE = 34;
    private static final int SEARCH_TYPE_CHOICE_END = 51;
    @SuppressWarnings("unused")
    private static final int SEARCH_TYPE_DISPATCH = 51;
    private static final int SEARCH_TYPE_LINEAR_MANY = 68;

    /**
     * Does the given state have <EM>no</EM> transitions?
     */
    private boolean terminalState(int state) {
        return data.getShort(state & -2) == SEARCH_TYPE_LINEAR + 0;
    }

    /**
     * Count the number of transitons out of the given state.
     */
    private int edgeCount(int state) {
        state &= -2;            // clear accept bit
        int ptr = state;
        int type = data.getShort(ptr);
        if (type < 0) {
            throw new Take5RuntimeException(Take5Exception.UNSUPPORTED_STATE_TYPE);
        } else if (type == SEARCH_TYPE_BINARY + 0) {
            return 1;
        } else if (type == SEARCH_TYPE_BINARY + 1) {
            return 2;
        } else if (type < SEARCH_TYPE_BINARY_END) {
            assert(SEARCH_TYPE_BINARY == 0);
            // Skip searching the bottom half of the space since we know
            // the final character must be in the top half.
            ptr += (1 << (type - SEARCH_TYPE_BINARY));
            switch (type) {
            case SEARCH_TYPE_BINARY + 16:
                if (charData[(ptr + (1 << 15)) >> 1] != '\uFFFF') {
                    ptr += (1 << 15);
                }
            case SEARCH_TYPE_BINARY + 15:
                if (charData[(ptr + (1 << 14)) >> 1] != '\uFFFF') {
                    ptr += (1 << 14);
                }
            case SEARCH_TYPE_BINARY + 14:
                if (charData[(ptr + (1 << 13)) >> 1] != '\uFFFF') {
                    ptr += (1 << 13);
                }
            case SEARCH_TYPE_BINARY + 13:
                if (charData[(ptr + (1 << 12)) >> 1] != '\uFFFF') {
                    ptr += (1 << 12);
                }
            case SEARCH_TYPE_BINARY + 12:
                if (charData[(ptr + (1 << 11)) >> 1] != '\uFFFF') {
                    ptr += (1 << 11);
                }
            case SEARCH_TYPE_BINARY + 11:
                if (charData[(ptr + (1 << 10)) >> 1] != '\uFFFF') {
                    ptr += (1 << 10);
                }
            case SEARCH_TYPE_BINARY + 10:
                if (charData[(ptr + (1 << 9)) >> 1] != '\uFFFF') {
                    ptr += (1 << 9);
                }
            case SEARCH_TYPE_BINARY + 9:
                if (charData[(ptr + (1 << 8)) >> 1] != '\uFFFF') {
                    ptr += (1 << 8);
                }
            case SEARCH_TYPE_BINARY + 8:
                if (charData[(ptr + (1 << 7)) >> 1] != '\uFFFF') {
                    ptr += (1 << 7);
                }
            case SEARCH_TYPE_BINARY + 7:
                if (charData[(ptr + (1 << 6)) >> 1] != '\uFFFF') {
                    ptr += (1 << 6);
                }
            case SEARCH_TYPE_BINARY + 6:
                if (charData[(ptr + (1 << 5)) >> 1] != '\uFFFF') {
                    ptr += (1 << 5);
                }
            case SEARCH_TYPE_BINARY + 5:
                if (charData[(ptr + (1 << 4)) >> 1] != '\uFFFF') {
                    ptr += (1 << 4);
                }
            case SEARCH_TYPE_BINARY + 4:
                if (charData[(ptr + (1 << 3)) >> 1] != '\uFFFF') {
                    ptr += (1 << 3);
                }
            case SEARCH_TYPE_BINARY + 3:
                if (charData[(ptr + (1 << 2)) >> 1] != '\uFFFF') {
                    ptr += (1 << 2);
                }
            case SEARCH_TYPE_BINARY + 2:
                if (charData[(ptr + 2) >> 1] == '\uFFFF') {
                    ptr += 2;
                } else {
                    ptr += 4;
                }
                break;
            }
        } else if (type < SEARCH_TYPE_LINEAR_END) {
            assert(SEARCH_TYPE_LINEAR == SEARCH_TYPE_BINARY_END);
            return type - SEARCH_TYPE_LINEAR;
        } else if (type < SEARCH_TYPE_CHOICE_END) {
            assert(SEARCH_TYPE_CHOICE == SEARCH_TYPE_LINEAR_END);
            return type - SEARCH_TYPE_CHOICE;
        } else if (type == SEARCH_TYPE_LINEAR_MANY) {
            while (charData[(ptr += 2) >> 1] != '\uFFFF') {
                ;
            }
        } else {
            throw new Take5RuntimeException(Take5Exception.UNSUPPORTED_STATE_TYPE);
        }
        /* If we get here, ptr points to the last character, but that may,
           or may not, be a guard edge. */
        int i = (ptr - state) >> 1;
        if (data.getInt(state - (8 * i) + 4) == guardIndexDelta) {
            return i - 1;
        } else {
            return i;
        }
    }

    /**
     * Given a starting state (represented as a {@link Take5Match}), return
     * an array of "matches", one for each possible state transition away
     * from this state.  Note that the matches are not necessarily actual
     * matches.
     * <P>
     * Use this in preference to {@link #nextLetters(int, int)}.
     *
     * @param start a Take5Match representing the starting state
     * @return an array of matches
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     * @see Take5Match#isAcceptState
     * @see Take5Match#c
     */
    public Take5Match[] nextLetters(Take5Match start)
        throws Take5Exception {
        return nextLettersInternal(start.state, start.index, start.length + 1);
    }

    /**
     * Given a starting state (represented as a pair of internal 32-bit
     * numbers), return an array of "matches", one for each possible state
     * transition away from this state.  Note that the matches are not
     * necessarily actual matches.
     * <P>
     * In order to call this, you have to break open the {@link Take5Match}
     * abstraction to obtain the state and index.  This is
     * <EM>horrible</EM>, but the proper way to do it is to use the slots
     * {@link Take5Match#state} and {@link Take5Match#index} directly.  (In
     * particular, you must <EM>not</EM> call {@link
     * Take5Match#getIndex()}.)
     *
     * @param state a 32-bit internal state
     * @param index a 32-bit internal index
     * @return an array of matches
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     * @deprecated Use {@link #nextLetters(Take5Match)}.
     */
    @Deprecated
    public Take5Match[] nextLetters(int state, int index)
        throws Take5Exception {
        return nextLettersInternal(state, index, 0);
    }

    private Take5Match[] nextLettersInternal(int state, int index, int length)
        throws Take5Exception {
        if (fsaEngine != ENGINE_SEARCH) {
            throw new UnsupportedOperationException("This Take5Dictionary is not a state machine.");
        }
        state &= -2;        // clear accept bit
        int edges = edgeCount(state);
        Take5Match[] rv = new Take5Match[edges];
        int edge = state;
        int ptr = state;
        Take5Match match;
        for (int i = 0; i < edges; ++i) {
            edge -= 8;
            ptr += 2;
            match = new Take5Match(this, length,
                                   index + data.getInt(edge + 4),
                                   state + data.getInt(edge));
            match.c = charData[ptr >> 1];
            rv[i] = match;
        }
        return rv;
    }

    // Is anybody using this?  How can it possibly be useful?  XXX
    /**
     * Given a starting state (represented as a "match"), check to see if
     * the addition of a single character would result in a match.
     *
     * @param m a Take5Match representing the starting state
     * @param c a character to consider
     * @return a match or null
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     */
    public Take5Match advanceByChar(Take5Match m, char c) throws Take5Exception {
        char[] cA = new char[1];
        cA[0] = c;
        Take5Match ret = new Take5Match();
        take5SearchInternal(cA, 0, 1, ret, null, m.state, m.index);
        if (ret.length == 0) {
            return null;
        }
        return ret;
    }

    /**
     * Lookup a key in the dictionary.  If match is not null then a search
     * for the longest match is performed.  If matches is not null then a
     * search for multiple matches, up to the length of matches, is
     * performed.  In either case, the total number of matches found is
     * returned, even if that number is larger than the number requested.
     * <P>
     * Only one of 'match' and 'matches' may be non-null.  If none or both
     * of match and matches are null then an IllegalArgumentException is
     * thrown.
     *
     * @param input array containing the key to look up.
     * @param offset the offset of the first character of the key.
     * @param length the length of the key.
     * @param match result object for longest match.
     * @param matches result object for multiple match.
     * @return the number of matches found
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     */
    public int take5Search(char[] input, int offset, int length,
                           Take5Match match, Take5Match[] matches) {
        return take5SearchInternal(input, offset, length, match, matches,
                                   stateStart, indexStart);
    }

    /**
     * Given a starting state (represented as a {@link Take5Match}), lookup
     * a key in the dictionary.  See {@link #take5Search(char[], int, int,
     * Take5Match, Take5Match[])} for the rest of the description.
     * <P>
     * Use this in preference to {@link #take5Search(char[], int, int,
     * Take5Match, Take5Match[], int, int)}.
     *
     * @param input array of characters containing the key to look up
     * @param offset offset of the first character of the key
     * @param length length of the key
     * @param match If non-null, do a longest match and return the results here.
     * @param matches If non-null, do a multiple-match lookup and return the results here.
     * @param start a Take5Match representing the starting state
     * @return the number of matches found
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     */
    public int take5Search(char[] input, int offset, int length,
                           Take5Match match, Take5Match[] matches,
                           Take5Match start) {
        return take5SearchInternal(input, offset, length, match, matches,
                                   start.state, start.index);
    }

    /**
     * Given a starting state (represented as a pair of internal 32-bit
     * numbers), lookup a key in the dictionary.  See {@link
     * #take5Search(char[], int, int, Take5Match, Take5Match[])} for the
     * rest of the description.
     * <P>
     * In order to call this, you have to break open the {@link Take5Match}
     * abstraction to obtain the state and index.  This is
     * <EM>horrible</EM>, but the proper way to do it is to use the slots
     * {@link Take5Match#state} and {@link Take5Match#index} directly.  (In
     * particular, you must <EM>not</EM> call {@link
     * Take5Match#getIndex()}.)
     *
     * @param input array of characters containing the key to look up
     * @param offset offset of the first character of the key
     * @param length length of the key
     * @param match If non-null, do a longest match and return the results here.
     * @param matches If non-null, do a multiple-match lookup and return the results here.
     * @param startState a 32-bit internal state
     * @param startIndex a 32-bit internal index
     * @return the number of matches found
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     * @deprecated Use {@link #take5Search(char[], int, int,
     *                  Take5Match, Take5Match[], Take5Match)}.
     */
    @Deprecated
    public int take5Search(char[] input, int offset, int length,
                           Take5Match match, Take5Match[] matches,
                           int startState, int startIndex)
        throws Take5Exception {
        return take5SearchInternal(input, offset, length, match, matches, startState, startIndex);
    }

    private int take5SearchInternal(char[] input, int offset, int length,
                                    Take5Match match, Take5Match[] matches,
                                    int startState, int startIndex) {
        int state = startState;
        int index = startIndex;
        int out_cnt = 0;
        int ptr;
        int cnt;
        char c;
        boolean squeezing = false;

        if (fsaEngine != ENGINE_SEARCH) {
            throw new UnsupportedOperationException("This Take5Dictionary is not a state machine.");
        }

        if (input == null) {
            throw new IllegalArgumentException("'input' must not be null");
        }
        if ((match == null) == (matches == null)) {
            throw new IllegalArgumentException("'match' and 'matches' are mutually exclusive");
        }

        if (match != null) {
            match.dict = this;
        }

        int limit = offset + length;
        loop: for (cnt = offset; cnt < limit; cnt++) {
            c = input[cnt];

            // If we're squeezing spaces, then we skip all but the first
            // space in a run of spaces.
            if (squeezeSpaces) {
                if (c == 0x0020) {
                    if (squeezing) continue;
                    squeezing = true;
                } else {
                    squeezing = false;
                }
            }

            // Check value in skipBits.
            if (skipBits != null && (skipBits[c >> 3] & 1 << (c & 7)) != 0) {
                continue;
            }

            // Check if we have just traversed an accept arc.
            if ((state & 1) != 0) {
                state &= -2;    // clear accept bit
                if (match != null) {
                    match.length = cnt - offset;
                    match.index = index;
                    match.state = state;
                } else if (matches != null && out_cnt < matches.length) {
                    matches[out_cnt] = new Take5Match(this, cnt - offset, index, state);
                }
                out_cnt++;
            }

            ptr = state;

            // Switch on the type code.
            short stateType = data.getShort(ptr);
            switch (stateType) {
            default:
                throw new Take5RuntimeException(Take5Exception.UNSUPPORTED_STATE_TYPE,
                                                "State: " + Integer.toString(stateType));

                // SEARCH_TYPE_DISPATCH is depreciated.  The code to
                // support it has been deleted from here.  The compiler
                // <EM>never</EM> generated these type codes and enough
                // people have come to depend on that fact that we have
                // declared them to be depreciated.  It is therefore
                // officially safe to depend on never encountering them.

                // Empty state: In fact the compiler has always generated
                // ..._LINEAR+0 for an empty state, and that fact is now
                // <EM>guaranteed</EM>, so we <EM>could</EM> signal an
                // error if we see ..._CHOICE+0.
            case SEARCH_TYPE_LINEAR + 0:
            case SEARCH_TYPE_CHOICE + 0:
                break loop;

                // Extended linear search:
            case SEARCH_TYPE_LINEAR_MANY:
                while (c > charData[(ptr += 2) >> 1]) {
                    ;
                }
                break;

                // Linear search:
            case SEARCH_TYPE_LINEAR + 16:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 15:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 14:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 13:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 12:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 11:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 10:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 9:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 8:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 7:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 6:
            case SEARCH_TYPE_CHOICE + 6:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 5:
            case SEARCH_TYPE_CHOICE + 5:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 4:
            case SEARCH_TYPE_CHOICE + 4:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 3:
            case SEARCH_TYPE_CHOICE + 3:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 2:
            case SEARCH_TYPE_CHOICE + 2:
            case SEARCH_TYPE_BINARY + 1:
                if (c <= charData[(ptr += 2) >> 1]) {
                    break;
                }
            case SEARCH_TYPE_LINEAR + 1:
            case SEARCH_TYPE_CHOICE + 1:
            case SEARCH_TYPE_BINARY + 0:
                ptr += 2;
                break;

                // Binary search:
            case SEARCH_TYPE_BINARY + 16:
                if (c > charData[(ptr + (1 << 16)) >> 1]) {
                    ptr += 1 << 16;
                }
            case SEARCH_TYPE_BINARY + 15:
                if (c > charData[(ptr + (1 << 15)) >> 1]) {
                    ptr += 1 << 15;
                }
            case SEARCH_TYPE_BINARY + 14:
                if (c > charData[(ptr + (1 << 14)) >> 1]) {
                    ptr += 1 << 14;
                }
            case SEARCH_TYPE_BINARY + 13:
                if (c > charData[(ptr + (1 << 13)) >> 1]) {
                    ptr += 1 << 13;
                }
            case SEARCH_TYPE_BINARY + 12:
                if (c > charData[(ptr + (1 << 12)) >> 1]) {
                    ptr += 1 << 12;
                }
            case SEARCH_TYPE_BINARY + 11:
                if (c > charData[(ptr + (1 << 11)) >> 1]) {
                    ptr += 1 << 11;
                }
            case SEARCH_TYPE_BINARY + 10:
                if (c > charData[(ptr + (1 << 10)) >> 1]) {
                    ptr += 1 << 10;
                }
            case SEARCH_TYPE_BINARY + 9:
                if (c > charData[(ptr + (1 << 9)) >> 1]) {
                    ptr += 1 << 9;
                }
            case SEARCH_TYPE_BINARY + 8:
                if (c > charData[(ptr + (1 << 8)) >> 1]) {
                    ptr += 1 << 8;
                }
            case SEARCH_TYPE_BINARY + 7:
                if (c > charData[(ptr + (1 << 7)) >> 1]) {
                    ptr += 1 << 7;
                }
            case SEARCH_TYPE_BINARY + 6:
                if (c > charData[(ptr + (1 << 6)) >> 1]) {
                    ptr += 1 << 6;
                }
            case SEARCH_TYPE_BINARY + 5:
                if (c > charData[(ptr + (1 << 5)) >> 1]) {
                    ptr += 1 << 5;
                }
            case SEARCH_TYPE_CHOICE + 9:
            case SEARCH_TYPE_CHOICE + 10:
            case SEARCH_TYPE_CHOICE + 11:
            case SEARCH_TYPE_CHOICE + 12:
            case SEARCH_TYPE_CHOICE + 13:
            case SEARCH_TYPE_CHOICE + 14:
            case SEARCH_TYPE_CHOICE + 15:
            case SEARCH_TYPE_CHOICE + 16:
            case SEARCH_TYPE_BINARY + 4:
                if (c > charData[(ptr + (1 << 4)) >> 1]) {
                    ptr += 1 << 4;
                }
            case SEARCH_TYPE_CHOICE + 7:
            case SEARCH_TYPE_CHOICE + 8:
            case SEARCH_TYPE_BINARY + 3:
                if (c > charData[(ptr + (1 << 3)) >> 1]) {
                    ptr += 1 << 3;
                }
            case SEARCH_TYPE_BINARY + 2:
                if (c > charData[(ptr + (1 << 2)) >> 1]) {
                    ptr += 1 << 2;
                }
                if (c > charData[(ptr += 2) >> 1]) {
                    ptr += 2;
                }
                break;
            }

            if (c != charData[ptr >> 1]) {
                break loop;
            }
            int edge = state - 4 * (ptr - state);
            state += data.getInt(edge);
            index += data.getInt(edge + 4);
        }

        if ((state & 1) != 0) {
            state &= -2; // clear accept bit
            if (match != null) {
                match.length = cnt - offset;
                match.index = index;
                match.state = state;
            } else if (matches != null && out_cnt < matches.length) {
                matches[out_cnt] = new Take5Match(this, cnt - offset, index, state);
            }
            out_cnt++;
        }

        return out_cnt;
    }

    /**
     * Turn an index back into the word that would generate it.
     *
     * @param index the index of the desired word
     * @param buffer array of chars to contain the word
     * @return the length of the word
     * @throws UnsupportedOperationException if the dictionary is not reversable.
     */
    public int reverseLookup(int index, char[] buffer) throws Take5Exception {
        if (fsaEngine != ENGINE_SEARCH) {             // X!X!X but this <EM>could</EM> work.
            throw new UnsupportedOperationException("This Take5Dictionary is not reversable.");
        }
        if (index < 0 || index >= indexCount) {
            throw new Take5Exception(Take5Exception.IMPOSSIBLE_HASH);
        }
        if (buffer.length < maxWordLength) {
            throw new Take5Exception(Take5Exception.BUFFER_TOO_SMALL);
        }
        // maxWordLength wasn't set until 5.2, so we wouldn't be on solid
        // ground before that version:
        if (fileVersion < VERSION_5_2) {
            throw new Take5Exception(Take5Exception.FILE_TOO_OLD);
        }
        int i = 0;              // index into buffer
        int state = stateStart;
        /* delta is the difference between the index we're looking for and
           the index accumulated on the path through the FSA so far: */
        int delta = index + indexOffset - indexStart;
        while (delta > 0) {
            state &= -2;        // clear accept bit
            int edge = state - 8;
            int ptr = state;
            int xdelta;
            switch (data.getShort(ptr)) {

            default:
                throw new Take5Exception(Take5Exception.UNSUPPORTED_STATE_TYPE);

                /* Encountering a state with <EM>no</EM> edges should be
                   impossible during a reverse lookup. */
            case SEARCH_TYPE_LINEAR + 0:
            case SEARCH_TYPE_CHOICE + 0:
                throw new Take5Exception(Take5Exception.BAD_DATA);

                /*
                 * CAUTION: Do not use '<' when you should be using
                 * 'unsignedLess'!
                 */

            case SEARCH_TYPE_LINEAR_MANY:
                /* Since no production release of the builder has ever
                   generated this state code, we can safely assume that if
                   we <EM>do</EM> encounter it, it will be properly
                   formatted with 0xFFFFFFFF in the final index_delta. */
                while (!unsignedLess(delta, data.getInt(edge - 8 + 4))) {
                    edge -= 8;
                }
                break;

            case SEARCH_TYPE_LINEAR + 16:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 15:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 14:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 13:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 12:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 11:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 10:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 9:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 8:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 7:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 6:
            case SEARCH_TYPE_CHOICE + 6:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 5:
            case SEARCH_TYPE_CHOICE + 5:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 4:
            case SEARCH_TYPE_CHOICE + 4:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 3:
            case SEARCH_TYPE_CHOICE + 3:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 2:
            case SEARCH_TYPE_CHOICE + 2:
            case SEARCH_TYPE_BINARY + 1:
                if (unsignedLess(delta, data.getInt(edge - 8 + 4))) break;
                edge -= 8;
            case SEARCH_TYPE_LINEAR + 1:
            case SEARCH_TYPE_CHOICE + 1:
            case SEARCH_TYPE_BINARY + 0:
                break;

            case SEARCH_TYPE_BINARY + 16:
                if (charData[(ptr + (1 << 16)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 16) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 16);
                        edge -= (4 << 16);
                    }
                }
            case SEARCH_TYPE_BINARY + 15:
                if (charData[(ptr + (1 << 15)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 15) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 15);
                        edge -= (4 << 15);
                    }
                }
            case SEARCH_TYPE_BINARY + 14:
                if (charData[(ptr + (1 << 14)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 14) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 14);
                        edge -= (4 << 14);
                    }
                }
            case SEARCH_TYPE_BINARY + 13:
                if (charData[(ptr + (1 << 13)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 13) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 13);
                        edge -= (4 << 13);
                    }
                }
            case SEARCH_TYPE_BINARY + 12:
                if (charData[(ptr + (1 << 12)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 12) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 12);
                        edge -= (4 << 12);
                    }
                }
            case SEARCH_TYPE_BINARY + 11:
                if (charData[(ptr + (1 << 11)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 11) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 11);
                        edge -= (4 << 11);
                    }
                }
            case SEARCH_TYPE_BINARY + 10:
                if (charData[(ptr + (1 << 10)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 10) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 10);
                        edge -= (4 << 10);
                    }
                }
            case SEARCH_TYPE_BINARY + 9:
                if (charData[(ptr + (1 << 9)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 9) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 9);
                        edge -= (4 << 9);
                    }
                }
            case SEARCH_TYPE_BINARY + 8:
                if (charData[(ptr + (1 << 8)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 8) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 8);
                        edge -= (4 << 8);
                    }
                }
            case SEARCH_TYPE_BINARY + 7:
                if (charData[(ptr + (1 << 7)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 7) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 7);
                        edge -= (4 << 7);
                    }
                }
            case SEARCH_TYPE_BINARY + 6:
                if (charData[(ptr + (1 << 6)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 6) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 6);
                        edge -= (4 << 6);
                    }
                }
            case SEARCH_TYPE_BINARY + 5:
                if (charData[(ptr + (1 << 5)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 5) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 5);
                        edge -= (4 << 5);
                    }
                }
            case SEARCH_TYPE_CHOICE + 9:
            case SEARCH_TYPE_CHOICE + 10:
            case SEARCH_TYPE_CHOICE + 11:
            case SEARCH_TYPE_CHOICE + 12:
            case SEARCH_TYPE_CHOICE + 13:
            case SEARCH_TYPE_CHOICE + 14:
            case SEARCH_TYPE_CHOICE + 15:
            case SEARCH_TYPE_CHOICE + 16:
            case SEARCH_TYPE_BINARY + 4:
                if (charData[(ptr + (1 << 4)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 4) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 4);
                        edge -= (4 << 4);
                    }
                }
            case SEARCH_TYPE_CHOICE + 7:
            case SEARCH_TYPE_CHOICE + 8:
            case SEARCH_TYPE_BINARY + 3:
                if  (charData[(ptr + (1 << 3)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 3) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 3);
                        edge -= (4 << 3);
                    }
                }
            case SEARCH_TYPE_BINARY + 2:
                if (charData[(ptr + (1 << 2)) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - (4 << 2) + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        ptr += (1 << 2);
                        edge -= (4 << 2);
                    }
                }
                if (charData[(ptr + 2) >> 1] != '\uFFFF') {
                    xdelta = data.getInt(edge - 8 + 4);
                    if (!unsignedLess(delta, xdelta) && xdelta != 0) {
                        edge -= 8;
                    }
                }
                break;
            }
            int stateDelta = data.getInt(edge);
            int indexDelta = data.getInt(edge + 4);
            assert(!unsignedLess(delta, indexDelta));
            if (indexDelta == delta && (stateDelta & 1) == 0) {
                /* It is possible (and unavoidable) that we might overshoot
                   by just one edge when we get down to zero, but if the
                   accept bit isn't set, we should have taken the previous
                   edge. */
                edge += 8;
                stateDelta = data.getInt(edge);
                indexDelta = data.getInt(edge + 4);
            }
            assert(edge < state);
            buffer[i++] = charData[(state + (state - edge) / 4) >> 1];
            state += stateDelta;
            delta -= indexDelta;
        }
        assert((state & 1) != 0);
        return i;
    }

    /**
     * Explore the dictionary tree starting from a given state, to a given
     * depth.  The first <CODE>start.length</CODE> characters in
     * <CODE>buffer</CODE> will be ignored.  Only the first
     * <CODE>buflen</CODE> characters in <CODE>buffer</CODE> will be used.
     * The exploration is thus limited to a depth of <CODE>buflen -
     * start.length</CODE>.
     * <P>
     * The given {@link Take5Walker} will be invoked for each "interesting"
     * state in the tree.  There are three kinds of interesting states:
     * <UL>
     * <LI> An accept state.  {@link Take5Walker#foundAccept
     * Take5Walker.foundAccept} is invoked.
     * <LI> A state at the given depth, beyond which there are more states.
     * {@link Take5Walker#foundLimit Take5Walker.foundLimit} is invoked.
     * <LI> A state at the given depth, beyond which there are more
     * states, which is also an accept state.  {@link
     * Take5Walker#foundBoth Take5Walker.foundBoth} is invoked.
     * </UL>
     * Whichever Take5Walker method is invoked, it will be passed a
     * Take5Match representing the state, and the appropriate characters
     * will have been stored in <CODE>buffer</CODE>.
     *
     * @param walker a {@link Take5Walker} to invoke for each interesting state
     * @param start a Take5Match representing the starting state
     * @param buffer an array of characters for storing found keys
     * @param buflen the length of the array to use
     * @throws UnsupportedOperationException if the dictionary is not a state machine.
     */
    public void walk(Take5Walker walker,
                     Take5Match start,
                     char[] buffer, int buflen)
        throws Take5Exception {
        if (fsaEngine != ENGINE_SEARCH) {
            throw new UnsupportedOperationException("This Take5Dictionary is not a state machine.");
        }
        if (start.length > buflen || buflen > buffer.length) {
            throw new Take5Exception(Take5Exception.BUFFER_TOO_SMALL);
        }
        Take5Match m = new Take5Match();
        m.dict = start.dict;
        walkInternal(walker, m, buffer, buflen, start.state, start.index, start.length);
    }

    private void walkInternal(Take5Walker w, Take5Match m, char[] buffer, int buflen,
                              int state, int index, int i)
        throws Take5Exception {
        if (i < buflen) {
            if ((state & 1) != 0) {
                state &= -2;          // clear accept bit
                m.state = state;
                m.index = index;
                m.length = i;
                w.foundAccept(m, buffer, buflen);
            }
            int nedges = edgeCount(state);
            for (int idx = 1; idx <= nedges; ++idx) {
                int edge = state - 8 * idx;
                buffer[i] = charData[(state + 2 * idx) >> 1];
                walkInternal(w, m, buffer, buflen,
                             state + data.getInt(edge),
                             index + data.getInt(edge + 4),
                             i + 1);
            }
        } else {
            m.state = state & -2; // clear accept bit
            m.index = index;
            m.length = i;
            if (terminalState(state)) {
                if ((state & 1) != 0) {
                    w.foundAccept(m, buffer, buflen);
                } else {
                    /* This shouldn't happen, given the current compiler,
                       but it is possible that some future compiler would
                       want to generate this case.  Thus it wouldn't be a
                       good idea to signal an error here -- instead we just
                       quietly do nothing. */
                }
            } else {
                if ((state & 1) != 0) {
                    w.foundBoth(m, buffer, buflen);
                } else {
                    w.foundLimit(m, buffer, buflen);
                }
            }
        }
    }

    private int perfectHashLookup(char[] key, int offset, int length, Take5Match match) {
        int end = offset + length;
        int hash = fnvHash(0, key, offset, end);
        int idx = data.getInt(stateStart + (hash % tableCount) * 4);
        if (idx >= indexCount) {
            idx = fnvHash(idx, key, offset, end) % indexCount;
        }
        switch (keyCheckFormat) {

        case KEYCHECK_FORMAT_STR:
            int ptr = data.getInt(keyCheckData + idx * 4);
            if (ptr == 0) {
                return 0;
            }
            for (int i = offset; i < end; i++) {
                if (key[i] != data.getChar(ptr)) {
                    return 0;
                }
                ptr += 2;
            }
            if (data.getChar(ptr) != 0) {
                return 0;
            }
            break;

        case KEYCHECK_FORMAT_HASH32:
            if (hash != data.getInt(keyCheckData + idx * 4)) {
                return 0;
            }
            break;

        case KEYCHECK_FORMAT_NONE:
            break;

        default:
            throw new Take5RuntimeException(Take5Exception.UNSUPPORTED_KEYCHECK_FORMAT);
        }
        match.dict = this;
        match.length = length;
        match.index = idx;
        return 1;
    }

    // See: <http://tools.ietf.org/html/draft-eastlake-fnv-07> for info on the FNV family of
    // hash functions.  (Replace the link above when/if it becomes an RFC.)
    private static final int FNV32_PRIME = 0x01000193;
    private static final int FNV32_BASE = 0x7B1B7853;
    private static final int fnvHash(int fun, char[] key, int i, int end) {
        int rv = ((fun + 1) * FNV32_BASE) & 0xFFFFFFFF;
        while (i < end) {
            rv ^= key[i++];
            rv = (rv * FNV32_PRIME) & 0xFFFFFFFF;
        }
        if ((rv & 0x80000000) != 0) {
            rv ^= 0x80000001;
        }
        return rv;
    }

    /**
     * Unsigned comparison.  It's annoying to know that the hardware almost
     * certainly has an instruction to do this, but we can't get at it.
     */
    private static final boolean unsignedLess(int x, int y) {
        return (x ^ 0x80000000) < (y ^ 0x80000000);
    }

    /**
     * Byte-swap the given integer.
     */
    private static int reverseBytes(int i) {
        return i << 24 | i << 8 & 0xff0000 | i >> 8 & 0xff00 | i >> 24 & 0xff;
    }
}
